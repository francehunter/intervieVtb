
1. Методика НТ: какие разделы, сбор целей НТ, анализ системы, определение источников нагрузки и смежных систем


2. Виды нагрузочных тестов (макс.перф, стабильности, объемное, отказоустойчивости и т.д.), регрессионное в рамках релизов


3. Профиль НТ: что это, как выглядит, как строится, как на его основе скрипты строятся; как из статистики собрать профиль, пошагово (почасовая статистика за год, поминутная за неделю, посекундная за раб.день)


4. Мониторинг: бизнес-метрик (время отклика, ошибки от системы, интенсивность операций), на уровне "железа" (ЦПУ, ОП, диски) и на уровне программных метрик (очереди, пулы подключений к БД, java heap, threads)


5. Протоколы: общее понимание, стеки (как пример TCP/IP), связь


6. Протокол НТТР (методы, коды ответа, заголовки)
Протокол прикладного уровня для обмена гипертекстом между сервером и клиентами. Под методом понимается префикс в урле, который може принимать ряд занчений: OPTIONS - возможности сервера; GET - получение контента с сервера; HEAD - GET без бади (способ инвалидации кеша); POST - передача контента на сервер; PUT - как POST, только вместо контента передается урл, содержащий контент; PATCH - POST к части контента (гипертекстовый гит); TRACE - возвращает конечный полученный сервером запрос (можно посмотреть, что добавилось к оригиналу от проводящей цепочки).
В ответном сообщении существует понятие кода ответа как ans.split("\n")[1]. Коды - целые числа - разбиты на группы: 1хх - информационные; 2хх - вариации успеха; 3хх - перенаправление; 4хх - ошибки клиента; 5хх - ошибки сервера. 
В тексте запроса и ответа можно выделить понятие заголовка - это часть, располагающаяся между первой строкой и \r\n\r\n. Заголовок построен как словарь "ключ" - "значение". Запарсить можно text.split("\n").split(":") + trim().

7. Технологии REST и SOAP
REST - Representational State Transfer — «передача состояния представления» - архитектурный паттерн проектирования взаимодействия между приложениями.
Необходимые условия реализации:
- клиент-серверная архитектура (сервер хранит данные, клиент шаблонизирует и формирует запросы)
- стейтлес контракт (сервер не хранит состояние клиентов, а получает его из запроса)
- кеширование (хеширование ресурсов приводит к более коротким ответам)
- унификация интерфейса (данные отличаются от представления, сообщения самодостаточны, стандартизация представления)
- лейеринг (клиент абстагирован от бд, архитектуры бекэнда)
Профит:
- простота
- расширяемость
- перформанс на уровне кеша и шаблонизации
- надежность как стейтлес

SOAP - Simple Object Access Protocol - можно определить как антипод REST - для обмена в RPC - подразумевается состояние клиента. Представление данных в виде XML вида 
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
   <soap:Body>
     <getProductDetails xmlns="http://warehouse.example.com/ws">
       <productID>12345</productID>
     </getProductDetails>
   </soap:Body>
</soap:Envelope>
Видим большой оверхед на разметку.

8. Форматы XML и JSON

XML - eXtensible Markup Language - текстовая форма представления данных в виде древовидной структуры. Состоит из элементов. Элемент - комбинация открытого и закрытого тега <elname myattr1="3" myattr2="4">elvalue</elname>. Между тегами расположено значение elvalue, в косых открывающих скобках - множество аттрибутов myattr.
Требования:
- наличие корневого элемента
- клиент-серверная поддержка кодировок UTF-8/16
Для выборок разработан язык запросов XPath, который представляет собой резулярное выражение, возвращающее множество найденных элементов по заданной маске.

JSON - JavaScript Object Notation - текстовая форма представления данных в виде "ключ"->"значение". Значением может быть как скаляр (число, булев тип, строка), так и вектор (массив). Есть бинарное расширение bson (активно используется в нон реляционных бд, например mongo), занчительно меньший оверхед трафика. JavaScript френдли формат и может парситься eval().

9. LoadRunner: протокол web/http (способы записи, параметризация, корреляция и верификация)


10. LoadRunner: Контроллер, мониторинг и запуск тестов (распределенный запуск, отсроченный, collate результатов)


11. LoadRunner: Аналайзер, merge, auto-correlation


12. JMeter: сэмплеры, тред-группы, ассерты, экстракторы, параметризация, pasing


13. SQL: group by, having, join
GROUP BY - группировка результатов выборки. Влияет на работу агрегатных функций COUNT, MIN, MAX, AVG и SUM. Без применения GROUP BY агрегатные функции будут работать по всем столбцам, указанным в SELECT, иначе - по результатам группровки. Математический аналог для SUM - спектр - SELECT age, SUM(salary) as sum FROM workers GROUP BY age - распределение зарплаты по возрастам.
HAVING - это WHERE для результатов группировки.
JOIN - объединение множества строк из множества таблиц. Результат слияния каждой пары таблиц можно представить в виде



14. Oracle: AWR, планы запросов (как получить, как анализировать и какую инфу получать оттуда)


15. БД Postgres: vacuum/autovacuum, сбор статистики


16. Kafka: что это, как работает и ее метрики (лаги, например)


17. Автоматизация НТ (это в первую очередь про jenkins, maven, git)


18. Критерии качества НТ. Пример: НТ провели, все хорошо, а на проде - проблемы. В чем могут быть причины?
